%{
open Transpiler
open Transpiler.Helpers

let parse_error_rich = Some Helpers.error_handler
%}

%token <string> ID
%token <int> INT
%token <string> TEXT
%token <char> CHAR
%token TRUE FALSE
%token EQ LT LE GT GE MI PL GU
%token DETERMINISTIC NONDETERMINISTIC IS
%token SCHEME CLASS TYPE VALUE AXIOM END ALL EXISTS EXACTLY_ONE TS TR WHERE VARIABLE INIT_CONSTRAINT
%token COMMA COLON BAR LBRACKET RBRACKET QUOTE LPAREN RPAREN SLASH BSLASH PRIME
%token EOF

%left DETERMINISTIC NONDETERMINISTIC
%right IS
%left GU
%right EQ
%left LT LE GT GE 
%left MI PL


%start start
%type <Transpiler.Scheme option> start

%%

start: scheme                                                           { $1 }

scheme:
    | SCHEME TEXT EQ CLASS declarations END                             { Some ($2, List.rev $5) }
    
declarations:
    | declaration                                                       { [$1] }
    | declarations declaration                                          { $2 :: $1 }

declaration: 
    | TYPE type_declarations                                            { TypeDeclaration(List.rev $2) }
    | VALUE value_declarations                                          { Value(List.rev $2) }
    | AXIOM value_expressions                                           { AxiomDeclaration(List.rev $2) }
    | TS LBRACKET TEXT RBRACKET transition_systems END                  { TransitionSystemDeclaration($3, List.rev $5) } 

transition_systems:
    | transition_system                                                 { [$1] }
    | transition_systems transition_system                              { $2 :: $1 }   

transition_system:
    | VARIABLE variable_definitions                                     { Variable(List.rev $2) }
    | INIT_CONSTRAINT init_constraints                                  { InitConstraint(List.rev $2) }
    | TR value_expression                                               { TransitionRule($2, []) }
    
where:
    |                                                                   { [] }
    | WHERE named_rules                                                 { $2 }

named_rules:
    | LBRACKET TEXT RBRACKET EQ value_expression                        { [($2, $5)] }
    | named_rules COMMA LBRACKET TEXT RBRACKET EQ value_expression      { ($4, $7) :: $1 }
    
choice:
    | LBRACKET EQ RBRACKET                                              { Deterministic }
    | LBRACKET GT RBRACKET                                              { NonDeterministic } 
    
variable_definitions:
    | variable_definition                                               { [$1] }
    | variable_definitions COMMA variable_definition                    { $3 :: $1 }

variable_definition:
    | identifier COLON type_expression                                  { ($1, $3, None) }
    | identifier COLON type_expression COLON EQ value_expression        { ($1, $3, Some($6)) }

init_constraints:
    | value_expression                                                  { [$1] }
    | init_constraints SLASH BSLASH value_expression                    { $4 :: $1 } 
    
identifier:
    | TEXT                                                              { Identifier.Simple($1) }
    | TEXT LBRACKET typing_list RBRACKET                                { Identifier.Generic($1, $3) } 

value_expressions:
    | value_expression                                                  { [$1] }
    | value_expressions COMMA value_expression                          { ($3 :: $1 ) }

value_expression:
    | TRUE                                                              { ValueLiteral(VBool true) }
    | FALSE                                                             { ValueLiteral(VBool false) }
    | INT                                                               { ValueLiteral(VInt $1) }
    | QUOTE TEXT QUOTE                                                  { ValueLiteral(VText $2) }
    | TEXT                                                              { VName $1 }
    | TEXT PRIME                                                        { VPName $1 }
    | TEXT LBRACKET value_expressions RBRACKET                          { GenericName($1, $3) }
    | TEXT PRIME LBRACKET value_expressions RBRACKET                    { PGenericName($1, $4) }
    | quantifier typing_list IS value_expression                        { Quantified($1, $2, $4) }
    | LPAREN value_expression RPAREN                                    { $2 }
    | infix                                                             { $1 }

infix:
    | value_expression DETERMINISTIC value_expression                   { Infix($1, Deterministic, $3) }
    | value_expression NONDETERMINISTIC value_expression                { Infix($1, NonDeterministic, $3) }
    | value_expression GU value_expression                              { Infix($1, Guard, $3) } 
    | value_expression LT value_expression                              { Infix($1, LessThan, $3) } 
    | value_expression LE value_expression                              { Infix($1, LessThanOrEqual, $3) } 
    | value_expression EQ value_expression                              { Infix($1, Equal, $3) }
    | value_expression PL value_expression                              { Infix($1, Plus, $3) }
    
quantifier:
    | ALL                                                               { All }
    | EXISTS                                                            { Exists }
    | EXACTLY_ONE                                                       { ExactlyOne }
    | DETERMINISTIC                                                     { Quantifier.Deterministic }
    | NONDETERMINISTIC                                                  { Quantifier.NonDeterministic }
    
value_declarations:
    | value_declaration                                                 { [$1] }
    | value_declarations COMMA value_declaration                        { $3 :: $1 }

value_declaration:
    | TEXT COLON type_expression                                        { Typing(SingleTyping($1, $3)) }
    | TEXT LBRACKET typing_list RBRACKET COLON type_expression          { GenericValue($1, $3, $6) } 
    | TEXT COLON type_expression EQ value_expression                    { ExplicitValue($1, $3, $5) }

typing:
    | TEXT COLON type_expression                                        { SingleTyping($1, $3) }

typing_list:
    | rev_typing_list                                                   { List.rev $1 }

rev_typing_list:
    | typing                                                            { [$1] }
    | typing_list COMMA typing                                          { $3 :: $1 }

type_declarations:
    | TEXT type_definition                                              { [($1, $2)] }
    | type_declarations COMMA TEXT type_definition                      { ($3, $4) :: $1 }

type_definition:
    |                                                                   { Abstract }
    | EQ type_expression                                                { Concrete($2) }
    | EQ EQ type_declaration_union                                      { Union(List.rev $3) }
    
type_declaration_union:
    | TEXT BAR TEXT                                                     { [$3; $1] }
    | type_declaration_union BAR TEXT                                   { $3 :: $1 }
    
type_expression:
    | TEXT                                                              { TName($1) }
