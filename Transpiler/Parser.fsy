%{
open Transpiler
open Transpiler.Helpers

let parse_error_rich = Some Helpers.error_handler
%}

%token <string> ID
%token <int> INT
%token <string> TEXT
%token <char> CHAR
%token TRUE
%token FALSE
%token EQ LT LE GT GE
%token SCHEME
%token CLASS
%token TYPE
%token VALUE
%token END
%token COMMA COLON BAR LBRACKET RBRACKET
%token EOF

%start start
%type <Transpiler.Scheme option> start

%%

start: scheme                                                           { $1 }

scheme:
    | SCHEME TEXT EQ CLASS declarations END                             { Some ($2, List.rev $5) }
    
declarations:
    | declaration                                                       { [$1] }
    | declarations declaration                                          { $2 :: $1 }

declaration: 
    | TYPE type_declarations                                            { TypeDeclaration($2) }
    | VALUE value_declarations                                          { Value($2) }

value_declarations:
    | value_declaration                                                 { [$1] }
    | value_declarations COMMA value_declaration                        { $3 :: $1 }

value_declaration:
    | TEXT COLON type_expression                                        { ExplicitValue($1, $3, None) }
    | TEXT LBRACKET typing_list RBRACKET COLON type_expression          { GenericValue($1, $3, $6) } 

typing:
    | TEXT COLON type_expression                                        { SingleTyping($1, $3) }

typing_list:
    | typing                                                            { [$1] }
    | typing_list COMMA typing                                          { $3 :: $1 }

type_declarations:
    | TEXT type_definition                                              { [($1, $2)] }
    | type_declarations COMMA ID type_definition                        { ($3, $4) :: $1 }

type_definition:
    |                                                                   { Abstract }
    | EQ type_expression                                                { Concrete($2) }
    | EQ EQ type_declaration_union                                      { Union(List.rev $3) }
    
type_declaration_union:
    | TEXT BAR TEXT                                                     { [$3; $1] }
    | type_declaration_union BAR TEXT                                   { $3 :: $1 }
    
type_expression:
    | TEXT                                                              { Name($1) }
