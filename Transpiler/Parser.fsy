%{
open Transpiler
open Transpiler.Helpers

let parse_error_rich = Some Helpers.error_handler
%}

%token <string> ID
%token <int> INT
%token <string> TEXT
%token <char> CHAR
%token TRUE FALSE
%token EQ LT LE GT GE MI PL
%token SCHEME CLASS TYPE VALUE AXIOM END ALL EXISTS EXACTLY_ONE TS VARIABLE INIT_CONSTRAINT
%token COMMA COLON BAR LBRACKET RBRACKET QUOTE LPAREN RPAREN SLASH BSLASH
%token EOF

%start start
%type <Transpiler.Scheme option> start

%%

start: scheme                                                           { $1 }

scheme:
    | SCHEME TEXT EQ CLASS declarations END                             { Some ($2, List.rev $5) }
    
declarations:
    | declaration                                                       { [$1] }
    | declarations declaration                                          { $2 :: $1 }

declaration: 
    | TYPE type_declarations                                            { TypeDeclaration(List.rev $2) }
    | VALUE value_declarations                                          { Value(List.rev $2) }
    | AXIOM value_expressions                                           { AxiomDeclaration(List.rev $2) }
    | TS LBRACKET TEXT RBRACKET transition_systems END                  { TransitionSystemDeclaration($3, List.rev $5) } 

transition_systems:
    | transition_system                                                 { [$1] }
    | transition_systems transition_system                              { $2 :: $1 }   

transition_system:
    | VARIABLE variable_definitions                                     { Variable(List.rev $2) }
    | INIT_CONSTRAINT init_constraints                                  { InitConstraint(List.rev $2) }
    
variable_definitions:
    | variable_definition                                               { [$1] }
    | variable_definitions COMMA variable_definition                    { $3 :: $1 }

variable_definition:
    | identifier COLON type_expression                                  { ($1, $3, None) }
    | identifier COLON type_expression COLON EQ value_expression        { ($1, $3, Some($6)) }

init_constraints:
    | value_expression                                                  { [$1] }
    | init_constraints SLASH BSLASH value_expression                    { $4 :: $1 }
    
identifier:
    | TEXT                                                              { Identifier.Simple($1) }
    | TEXT LBRACKET typing_list RBRACKET                                { Identifier.Generic($1, $3) } 

value_expressions:
    | value_expression                                                  { [$1] }
    | value_expressions COMMA value_expression                          { ($3 :: $1 ) }

value_expression:
    | TRUE                                                              { ValueLiteral(VBool true) }
    | FALSE                                                             { ValueLiteral(VBool false) }
    | INT                                                               { ValueLiteral(VInt $1) }
    | QUOTE TEXT QUOTE                                                  { ValueLiteral(VText $2) }
    | TEXT                                                              { VName $1 }
    | TEXT LBRACKET value_expressions RBRACKET                          { GenericName($1, $3) }
    | value_expression EQ value_expression                              { Equivalence($1, $3) }
    | quantifier typing_list COLON MI value_expression                  { Quantified($1, $2, $5) }
    
quantifier:
    | ALL                                                               { All }
    | EXISTS                                                            { Exists }
    | EXACTLY_ONE                                                       { ExactlyOne }
    
value_declarations:
    | value_declaration                                                 { [$1] }
    | value_declarations COMMA value_declaration                        { $3 :: $1 }

value_declaration:
    | TEXT COLON type_expression                                        { Typing(SingleTyping($1, $3)) }
    | TEXT LBRACKET typing_list RBRACKET COLON type_expression          { GenericValue($1, $3, $6) } 
    | TEXT COLON type_expression EQ value_expression                    { ExplicitValue($1, $3, $5) }

typing:
    | TEXT COLON type_expression                                        { SingleTyping($1, $3) }

typing_list:
    | rev_typing_list                                                   { List.rev $1 }

rev_typing_list:
    | typing                                                            { [$1] }
    | typing_list COMMA typing                                          { $3 :: $1 }

type_declarations:
    | TEXT type_definition                                              { [($1, $2)] }
    | type_declarations COMMA TEXT type_definition                      { ($3, $4) :: $1 }

type_definition:
    |                                                                   { Abstract }
    | EQ type_expression                                                { Concrete($2) }
    | EQ EQ type_declaration_union                                      { Union(List.rev $3) }
    
type_declaration_union:
    | TEXT BAR TEXT                                                     { [$3; $1] }
    | type_declaration_union BAR TEXT                                   { $3 :: $1 }
    
type_expression:
    | TEXT                                                              { TName($1) }
