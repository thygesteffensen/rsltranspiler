%{
open Transpiler
open Transpiler.Helpers

let parse_error_rich = Some Helpers.error_handler
%}

%token <string> ID
%token <int> INT
%token <string> TEXT
%token <char> CHAR
%token TRUE
%token FALSE
%token EQ LT LE GT GE
%token SCHEME
%token CLASS
%token TYPE
%token END
%token COMMA COLON BAR
%token EOF

%start start
%type <Transpiler.Scheme option> start

%%

start: scheme                                   { $1 }

scheme:
    | SCHEME TEXT EQ CLASS declarations END     { Some ($2, $5) }

declarations: 
    | TYPE type_declarations                    { Type($2) }

type_declarations:
    | type_declaration                          { [$1] }
    | type_declarations COMMA type_declaration  { $3 :: $1 }

type_declaration:
    | TEXT                                      { Abstract($1) }
    | TEXT EQ type_expression                   { Concrete($1, $3) }
    | TEXT EQ type_declaration_union            { Union($1, List.rev $3) }
    
type_declaration_union:
    | TEXT                                      { [$1] }
    | type_declaration_union BAR TEXT           { $3 :: $1 }
    
type_expression:
    | TEXT                                      { Name($1) }
