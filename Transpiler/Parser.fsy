%{
open Transpiler.Ast
open FSharp.Text
open Transpiler.Helpers.Helpers

let parse_error_rich = Some error_handler
%}

%token <string * FSharp.Text.Lexing.Position> ID
%token <int * FSharp.Text.Lexing.Position> INT
%token <string * FSharp.Text.Lexing.Position> TEXT
%token <char * FSharp.Text.Lexing.Position> CHAR
%token<FSharp.Text.Lexing.Position> TRUE 
%token<FSharp.Text.Lexing.Position> FALSE 
%token<FSharp.Text.Lexing.Position> EQ LT LE GT GE MI PL GU
%token<FSharp.Text.Lexing.Position> DETERMINISTIC NONDETERMINISTIC IS
%token<FSharp.Text.Lexing.Position> SCHEME CLASS TYPE VALUE AXIOM END ALL EXISTS EXACTLY_ONE TS TR WHERE VARIABLE INIT_CONSTRAINT
%token<FSharp.Text.Lexing.Position> COMMA COLON BAR LBRACKET RBRACKET QUOTE LPAREN RPAREN SLASH BSLASH PRIME
%token<FSharp.Text.Lexing.Position> EOF

%left DETERMINISTIC NONDETERMINISTIC
%right IS
%left GU
%right EQ
%left LT LE GT GE 
%left MI PL


%start start
%type <Transpiler.Ast.Scheme option> start

%%

start: scheme                                                           { $1 }

scheme:
    | SCHEME TEXT EQ CLASS declarations END                             { Some ($2, List.rev $5) }
    
declarations:
    | declaration                                                       { [$1] }
    | declarations declaration                                          { $2 :: $1 }

declaration: 
    | TYPE type_declarations                                            { TypeDeclaration(List.rev $2) }
    | VALUE value_declarations                                          { Value(List.rev $2) }
    | AXIOM value_expressions                                           { AxiomDeclaration(List.rev $2) }
    | TS LBRACKET TEXT RBRACKET transition_systems END                  { TransitionSystemDeclaration($3, List.rev $5) } 

transition_systems:
    | transition_system                                                 { [$1] }
    | transition_systems transition_system                              { $2 :: $1 }   

transition_system:
    | VARIABLE variable_definitions                                     { Variable(List.rev $2) }
    | INIT_CONSTRAINT init_constraints                                  { InitConstraint(List.rev $2) }
    | TR value_expression where                                         { TransitionRule($2, $3) }
    
where:
    |                                                                   { [] }
    | WHERE named_rules                                                 { $2 }

named_rules:
    | LBRACKET TEXT RBRACKET EQ value_expression                        { [($2, $5)] }
    | named_rules COMMA LBRACKET TEXT RBRACKET EQ value_expression      { ($4, $7) :: $1 }
    
choice:
    | LBRACKET EQ RBRACKET                                              { Deterministic }
    | LBRACKET GT RBRACKET                                              { NonDeterministic } 
    
variable_definitions:
    | variable_definition                                               { [$1] }
    | variable_definitions COMMA variable_definition                    { $3 :: $1 }

variable_definition:
    | identifier COLON type_expression                                  { Typing(SingleTyping($1, $3)) }
    | identifier COLON type_expression COLON EQ value_expression        { ExplicitValue($1, $3, $6) }

init_constraints:
    | value_expression                                                  { [$1] }
    | init_constraints SLASH BSLASH value_expression                    { $4 :: $1 } 
    
identifier:
    | TEXT                                                              { ISimple($1) }
    | TEXT LBRACKET typing_list RBRACKET                                { IGeneric($1, $3) } 

value_expressions:
    | value_expression                                                  { [$1] }
    | value_expressions COMMA value_expression                          { ($3 :: $1 ) }

value_expression:
    | TRUE                                                              { let pos = $1
                                                                          ValueLiteral(VBool true, pos) }
    | FALSE                                                             { let pos = $1
                                                                          ValueLiteral(VBool false, pos) }
    | INT                                                               { let a, pos = $1
                                                                          ValueLiteral(VInt a, pos) }
    | QUOTE TEXT QUOTE                                                  { let text, _ = $2
                                                                          ValueLiteral(VText text, $1) }
    | accessor                                                          { $1 }
    | LBRACKET TEXT RBRACKET                                            { Rule $2 }
    | quantifier typing_list IS value_expression                        { Quantified($1, $2, $4) }
    | LPAREN value_expression RPAREN                                    { $2 }
    | infix                                                             { $1 }
    
accessor:
    | TEXT                                                              { VName (ASimple $1) }
    | TEXT PRIME                                                        { VPName (ASimple $1) }
    | TEXT LBRACKET value_expressions RBRACKET                          { VName(AGeneric($1, List.rev $3)) }
    | TEXT PRIME LBRACKET value_expressions RBRACKET                    { VPName(AGeneric($1, List.rev $4)) }

infix:
    | value_expression DETERMINISTIC value_expression                   { Infix($1, InfixOp.Deterministic, $3) }
    | value_expression NONDETERMINISTIC value_expression                { Infix($1, InfixOp.NonDeterministic, $3) }
    | value_expression GU list_expr                                     { Infix($1, Guard, VeList $3) } 
    | value_expression LT value_expression                              { Infix($1, LessThan, $3) } 
    | value_expression LE value_expression                              { Infix($1, LessThanOrEqual, $3) } 
    | value_expression EQ value_expression                              { Infix($1, Equal, $3) }
    | value_expression PL value_expression                              { Infix($1, Plus, $3) }
    
list_expr:
    | value_expression                                                  { [$1] }
    | list_expr COMMA value_expression                                  { $3 :: $1 }
    
quantifier:
    | ALL                                                               { (All, $1) }
    | EXISTS                                                            { (Exists, $1) }
    | EXACTLY_ONE                                                       { (ExactlyOne, $1) }
    | DETERMINISTIC                                                     { (Quantifier.Deterministic, $1) }
    | NONDETERMINISTIC                                                  { (Quantifier.NonDeterministic, $1) }
    
value_declarations:
    | value_declaration                                                 { [$1] }
    | value_declarations COMMA value_declaration                        { $3 :: $1 }

value_declaration:
    | identifier COLON type_expression                                  { Typing(SingleTyping($1, $3)) }
    | identifier LBRACKET typing_list RBRACKET COLON type_expression    { GenericValue($1, $3, $6) } 
    | identifier COLON type_expression EQ value_expression              { ExplicitValue($1, $3, $5) }

typing:
    | identifier COLON type_expression                                  { SingleTyping($1, $3) }

typing_list:
    | rev_typing_list                                                   { List.rev $1 }

rev_typing_list:
    | typing                                                            { [$1] }
    | typing_list COMMA typing                                          { $3 :: $1 }

type_declarations:
    | TEXT type_definition                                              { [($1, $2)] }
    | type_declarations COMMA TEXT type_definition                      { ($3, $4) :: $1 }

type_definition:
    |                                                                   { Abstract }
    | EQ type_expression                                                { Concrete($2) }
    | EQ EQ type_declaration_union                                      { Union(List.rev $3) }
    
type_declaration_union:
    | TEXT BAR TEXT                                                     { [$3; $1] }
    | type_declaration_union BAR TEXT                                   { $3 :: $1 }
    
type_expression:
    | TEXT                                                              { TName($1) }
