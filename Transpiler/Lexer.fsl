{

//module Lexer =

open FSharp.Text.Lexing
open System
open Parser

exception SyntaxError of string

let lexeme = LexBuffer<_>.LexemeString

let mutable line = 1
let mutable column = 1
let mutable filename = ""

/// <summary>
/// Set filename in Lexer and reset counters
/// </summary>
/// <param name="f">Filename of the file being lexed</param>
let setFilename (f: string) = 
    filename <- f
    line <- 1
    column <- 1

/// <summary>
/// Increment line counter and reset column counter
/// </summary>
let newline () = 
    line <- line + 1
    column <- 1
    
/// <summary>
/// Increment column counter based on whitespace
/// </summary>
/// <param name="lexbuf">LexBuffer</param>
let whitespace (lexbuf: LexBuffer<_>) =
    match lexbuf.LexemeChar 0 with
    | ' '  -> column <- column + 1
    | '\t' -> column <- column + 4
    | _ -> ()

/// <summary>
/// Increment column counter based on lexed string and return the current <see cref="FSharp.Text.Lexing.Position"/>
/// </summary>
/// <param name="lexbuf">LexBuffer</param>
let getPos (lexbuf: LexBuffer<_>) =
    let c = column
    column <- column + lexbuf.LexemeLength
    
    { pos_bol = lexbuf.StartPos.pos_cnum
      pos_cnum = c
      pos_fname = filename
      pos_lnum = line
      pos_orig_lnum = line }
  
// This is to avoid state explosion
// https://v2.ocaml.org/manual/lexyacc.html Section 7 Common errors
let keywords =   
    [   
        "class", CLASS;
        "scheme", SCHEME;
        "type", TYPE;
        "value", VALUE;
        "axiom", AXIOM;
        "end", END;
        "all", ALL;
        "exists", EXISTS;
        "exists!", EXACTLY_ONE;
        "transition_system", TS;
        "transition_rules", TR;
        "where", WHERE;
        "variable", VARIABLE;
        "init_constraint", INIT_CONSTRAINT;
    ] |> Map.ofList   
 
let ops =   
    [   
        "=",    EQ;   
        "==>",  GU;
        "<",    LT;   
        "<=",   LE;   
        ">",    GT;   
        ">=",   GE;   
        "-",    MI;
        "+",    PL;
        ":-",   IS;
        "[=]",  NONDETERMINISTIC;
        "[>]",  DETERMINISTIC;
    ] |> Map.ofList   
}


let c           = '.'
let white       = ' ' | '\t'
let newline     = '\r' | '\n' | "\r\n"

let char        = ['a'-'z' 'A'-'Z']   
let digit       = ['0'-'9']
let text  = char(char|digit|['-' '_' '.'])*   
let operator    = ">" | ">=" | "<" | "<=" | "=" | "-" | "+" | "==>" | "[=]" | "[>]" | ":-"


rule comment = parse
     |  char
        { let n, m, args = cargs
          if not skip then COMMENT (LexCont.Comment(args.ifdefStack, args.stringNest, n, m))
          else comment (n, m, args) skip lexbuf  }
    
     | '"'
        { let n, m, args = cargs
          if not skip then COMMENT (LexCont.StringInComment(args.ifdefStack, args.stringNest, LexerStringStyle.SingleQuote, n, m))
          else stringInComment n m args skip lexbuf }
    
     | '"' '"' '"'
        { let n, m, args = cargs
          if not skip then COMMENT (LexCont.StringInComment(args.ifdefStack, args.stringNest, LexerStringStyle.TripleQuote, n, m))
          else tripleQuoteStringInComment n m args skip lexbuf }
    
     | '@' '"'
        { let n, m, args = cargs
          if not skip then COMMENT (LexCont.StringInComment(args.ifdefStack, args.stringNest, LexerStringStyle.Verbatim, n, m))
          else verbatimStringInComment n m args skip lexbuf }
    
     | "(*)"
        { let n, m, args = cargs
          LexbufLocalXmlDocStore.AddGrabPoint(lexbuf)
          if not skip then COMMENT (LexCont.Comment(args.ifdefStack, args.stringNest, n, m))
          else comment cargs skip lexbuf }
    
     | '(' '*'
        { let n, m, args = cargs
          if not skip then COMMENT (LexCont.Comment(args.ifdefStack, args.stringNest, n+1, m))
          else comment (n+1,m,args) skip lexbuf }
    
     | newline
        { let n, m, args = cargs
          newline lexbuf
          if not skip then COMMENT (LexCont.Comment(args.ifdefStack, args.stringNest, n, m))
          else comment cargs skip lexbuf }
     | "*)"
        {
          let n, m, args = cargs
          if n > 1 then
              if not skip then COMMENT (LexCont.Comment(args.ifdefStack, args.stringNest, n-1, m))
              else comment (n-1,m,args) skip lexbuf
          else
              LexbufLocalXmlDocStore.AddGrabPointDelayed(lexbuf)
              if not skip then COMMENT (LexCont.Token(args.ifdefStack, args.stringNest))
              else
                  LexbufCommentStore.SaveBlockComment(lexbuf, m, lexbuf.LexemeRange) 
                  token args skip lexbuf }
    
     | [^ '\'' '(' '*' '\n' '\r' '"' ')' '@' ' ' '\t' ]+
        { let n, m, args = cargs
          if not skip then COMMENT (LexCont.Comment(args.ifdefStack, args.stringNest, n, m))
          else comment cargs skip lexbuf }
    
     | eof
         { let n, m, args = cargs
           EOF (LexCont.Comment(args.ifdefStack, args.stringNest, n, m)) }


rule read =
    parse
    | "(*"      { let m = lexbuf.LexemeRange
                  if not skip then COMMENT (LexCont.Comment(args.ifdefStack, args.stringNest, 1, m))
                  else comment (1,m,args) skip lexbuf }
    | white     { whitespace(lexbuf); read lexbuf }
    | newline   { newline (); read lexbuf }
    | "true"    { let start = getPos(lexbuf)
                  TRUE(start) }
    | "false"   { let start = getPos(lexbuf)
                  FALSE(start) }
    | operator  { let start = getPos(lexbuf)
                  ops.[lexeme lexbuf](start) } 
    | text      { let start = getPos(lexbuf)
                  match keywords.TryFind(lexeme lexbuf) with
                  | Some(token) -> token(start)
                  | None -> TEXT(lexeme lexbuf, (start))
                }
    | ','       { let start = getPos(lexbuf)
                  COMMA(start) }
    | ':'       { let start = getPos(lexbuf)
                  COLON(start) }
    | '['       { let start = getPos(lexbuf)
                  LBRACKET(start) }
    | ']'       { let start = getPos(lexbuf)
                  RBRACKET(start) }
    | '('       { let start = getPos(lexbuf)
                  LPAREN(start) }
    | ')'       { let start = getPos(lexbuf)
                  RPAREN(start) }
    | '|'       { let start = getPos(lexbuf)
                  BAR(start) }
    | '"'       { let start = getPos(lexbuf)
                  QUOTE(start) }
    | '/'       { let start = getPos(lexbuf)
                  SLASH(start) }
    | '\''      { let start = getPos(lexbuf)
                  PRIME(start) }
    | '\\'      { let start = getPos(lexbuf)
                  BSLASH(start) }
    | ['-']?digit+   { let start = getPos(lexbuf)
                       INT(Int32.Parse(lexeme lexbuf), (start))} 
    | eof       { EOF(lexbuf.EndPos) }
    | _         { EOF(lexbuf.EndPos) }
